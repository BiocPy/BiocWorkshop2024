# Tutorial 1: `GenomicRanges` and range-based analyses

Genomic range operations are fundamental to many bioinformatics analyses. They allow us to work with intervals of genomic coordinates, which is crucial for understanding the relationships between different genomic features such as genes, regulatory elements, and experimental data like ChIP-seq peaks. In this session, we'll explore how to work with genomic interval data using BiocPy packages, which provide Python implementations of popular Bioconductor tools.

## Outline

In this workshop, we'll walk through several key aspects of working with genomic ranges in Python:

1. Reading Genomic Data: We'll start by reading in genomic data from RDS files, including CpG islands and gene annotations.
2. Basic Genomic Operations: We'll cover fundamental operations like finding transcription start sites (TSS) and promoter regions.
3. Overlap Analysis: We'll learn how to find overlaps between different genomic features, a common task in many analyses.
4. Advanced Operations: We'll explore more complex operations like finding peaks within specific regions and resizing genomic intervals.

## Prerequisites

Before we begin, please ensure that you have the following installed:


### Installation

Let's start by installing the required packages for R and Python.

```r
BiocManager::install(c("TxDb.Hsapiens.UCSC.hg38.refGene"), 
     repos='http://cran.us.r-project.org')
```

You can install the Python packages using pip:

```bash
pip install biocutils genomicranges rds2py numpy pandas
```

## 0. Save Annotations as RDS

Lets download the human reference genome and save the exon positions group by transcripts.
We need do a bit of pre-processing to get this information.

For the purpose of the tutorial, we'll limit the exons to 'chromosome 22'.

```r
suppressMessages(library(TxDb.Hsapiens.UCSC.hg38.refGene))
genome <- TxDb.Hsapiens.UCSC.hg38.refGene
seqlevels(genome) <- "chr22"
exons_hg38 <- exonsBy(genome, by = "tx")

saveRDS(exons_hg38, "./hg38_exons_by_tx.rds")
```

## 1. Reading RDS files in Python

The [rds2py](https://github.com/biocpy/rds2py) Python package allows us to read RDS files and create equivalent Python representations of R objects. Key features include:

- Parsing common R objects into Python equivalents (e.g., matrices to NumPy arrays, data frames to Pandas DataFrames).
- Unique ability to read S4 classes, enabling direct parsing of Bioconductor data types from R to Python.
- Built on Aaron's [rds2cpp](https://github.com/LTLA/rds2cpp) library for efficient processing.

Reading an RDS file with rds2py involves two steps:

- Parse the RDS file into a Python dictionary containing data and metadata.
- Convert this dictionary into a suitable Python object using specific parser functions.

This process allows seamless transition between R and Python for bioinformatics analyses.

```{python}
from rds2py import read_rds

hg38_robject = read_rds("./hg38_exons_by_tx.rds")

from rds2py.granges import as_granges_list

hg38_grl = as_granges_list(hg38_robject)

print("\nhg38 genome exons by transcript \n")
print(hg38_grl)
```


## 2. Basic Genomic Operations

Now, let's perform some basic operations like finding transcription start sites (TSS) and promoter regions. These operations are fundamental in genomic analysis as they help us identify key regulatory regions of genes.

### 2.1 Finding Transcription Start Sites (TSS)

Transcription Start Sites (TSS) are the locations where transcription of a gene begins. Identifying TSS is crucial for understanding gene regulation, as many regulatory elements are located near the TSS. 

```{python}
tss = hg38_grl.range().as_genomic_ranges().resize(width=1, fix="start")

print("Transcription Start Sites:")
print(tss)
```

Here, we're using the `range()` method to get the full extent of each transcript, then resizing to a width of 1 base pair at the start of each range to pinpoint the TSS.

### 2.2 Defining Promoter Regions

Promoter regions are typically located upstream of the TSS and play a crucial role in regulating gene expression. Here, we're defining promoters as the region 2000 base pairs upstream to 200 base pairs downstream of each TSS. This definition can vary depending on the specific analysis, but this range often captures important regulatory elements.

```{python}
promoters = tss.promoters(upstream=2000, downstream=200)

print("Promoter Regions:")
print(promoters)
```

## 3. Overlap Analysis

A common task in genomic analysis is finding overlaps between different genomic features. This helps us understand the relationships between various elements in the genome and can provide insights into gene regulation and function.

### 3.1 Reading ChIP-seq Peaks

ChIP-seq (Chromatin Immunoprecipitation followed by sequencing) is a method used to identify binding sites of DNA-associated proteins. The peaks represent regions where a protein of interest is likely bound to the DNA. We're focusing on chromosome 22 for this example to keep the dataset manageable.

For the purpose of this tutorial, lets download a bed file containing peaks from a ChIP-seq experiments on "Human B cells" run by ENCODE and cataloged in [bedbase.org](https://bedbase.org/bed/be4054acf6e3feeb4dc490e6430e358e).

```{python}
from geniml.bbclient import BBClient

bbclient = BBClient(cache_folder="cache", bedbase_api="https://api.bedbase.org")
bedfile_id = "be4054acf6e3feeb4dc490e6430e358e" 
bedfile = bbclient.load_bed(bedfile_id)
peaks = bedfile.to_granges()

filter_chr22 = [x == "chr22" for x in peaks.get_seqnames()]
peaks_chr22 = peaks[filter_chr22]

print(peaks_chr22)
```

### 3.2 Finding Overlaps with TSS

Here, we're identifying ChIP-seq peaks that overlap with TSS. This analysis can help us understand if the protein of interest tends to bind near the start of genes, which could suggest a role in transcription initiation.

```{python}
overlaps = peaks_chr22.find_overlaps(tss)

print("Overlapping with TSS:")
print(len(overlaps))
```

:::{.callout-note}
Find overlaps returns a `list` with the same length as TSS, indicating which indices from peaks overlap with each of the TSS. Ideally, we would want to return a `Hits` object similar to Bioconductor implementation.
:::

we can iterate the indices from the object and filter the peaks that overlap with TSS

```{python}
import itertools

all_indices = list(set(itertools.chain.from_iterable(overlaps)))
peaks_with_tss = peaks_chr22[all_indices]
print(peaks_with_tss)
```


:::{.callout}
uh oh, no overlaps? well, the `'peaks'` object does not contain any strand information. Lets fix this by ignoring strand information (`ignore_strand=True`).
:::

```{python}
overlaps = peaks_chr22.find_overlaps(tss, ignore_strand=True)
print(len(overlaps))
all_indices = list(set(itertools.chain.from_iterable(overlaps)))
peaks_with_tss = peaks_chr22[all_indices]
print(peaks_with_tss)
```

Alternatively, one can subset peaks that overlap with TSS using the `subset_by_overlaps` method:

```{python}
peaks_with_tss2 = peaks_chr22.subset_by_overlaps(tss, ignore_strand=True)
print(peaks_with_tss2)
```

### 3.3 Finding Overlaps with Promoters

This operation finds ChIP-seq peaks that overlap with our defined promoter regions. If a significant number of peaks fall within promoters, it might suggest that the protein plays a role in gene regulation through promoter binding. This kind of analysis is often used to characterize the binding patterns of transcription factors or other regulatory proteins.

```{python}
peaks_with_promoters = peaks_chr22.subset_by_overlaps(promoters, ignore_strand=True)

print("Peaks Overlapping with Promoters:")
print(peaks_with_promoters)
```

### 3.4 Finding Overlaps with Exons

An advanced and more broadly applicable analysis is to look at overlaps with all exons. This can help identify potential roles of the ChIP-seq peaks in gene regulation, or splicing. Let's modify our analysis to look at all exons:

```{python}
# Combine all exons into a single GenomicRanges object
all_exons = hg38_grl.as_granges()

# Find peaks overlapping with any exon
peaks_with_exons = peaks_chr22.subset_by_overlaps(all_exons, ignore_strand=True)

print("Peaks overlapping with exons:")
print(peaks_with_exons)

# Calculate the percentage of peaks that overlap with exons
percent_overlapping = (len(peaks_with_exons) / len(peaks_chr22)) * 100

print(f"Percentage of peaks overlapping with exons: {percent_overlapping:.2f}%")
```

This analysis can provide insights into whether the protein of interest (captured by the ChIP-seq) tends to bind within gene bodies, potentially influencing gene expression, splicing, or other co-transcriptional processes.

## 4. Advanced Operations

Let's explore some more complex operations that are often used in genomic analyses.

### 4.1 Comparing Exonic vs. Intronic Binding

To gain further insight, we can compare the proportion of peaks overlapping with exons to those overlapping with introns:

```{python}
# Create intronic regions (regions within genes but not in exons)
gene_regions = all_exons.range()  # Get the full extent of genes
introns = gene_regions.subtract(all_exons).as_granges()

# Find peaks overlapping with introns
peaks_with_introns = peaks_chr22.subset_by_overlaps(introns, ignore_strand=True)

print("Peaks overlapping with introns:")
print(peaks_with_introns)

# Calculate percentages
percent_exonic = (len(peaks_with_exons) / len(peaks_chr22)) * 100
percent_intronic = (len(peaks_with_introns) / len(peaks_chr22)) * 100

print(f"Percentage of peaks overlapping with exons: {percent_exonic:.2f}%")
print(f"Percentage of peaks overlapping with introns: {percent_intronic:.2f}%")
```

This comparison can help determine if the protein of interest shows a preference for binding in exonic or intronic regions, which could suggest different functional roles (e.g., splicing regulation for exonic binding vs. potential enhancer activity for intronic binding).

### 4.2 Finding Overlaps with the first exon

Lets first put together a genomicranges that contains the first exon for each transcript.

```{python}
all_first = []
for txid, grl in hg38_grl:
    strand = grl.get_strand(as_type = "list")[0]
    if strand == "-":
        all_first.append(grl.sort()[-1])
    else:
        all_first.append(grl.sort()[0])
```

Then we combine all the individual genomic elements. The [biocutils](https://github.com/BiocPy/BiocUtils) package provides utilities mostly convenient aspects of R that aren't provided by base Python and generics. One of these generics is the `'combine'` operation that to merge or concatenate various Bioconductor classes.

```{python}
from biocutils import combine_sequences
first_exons = combine_sequences(*all_first)
```

We can now subset peaks that overlap with the first exon

```{python}
peaks_with_first_exons = peaks_chr22.subset_by_overlaps(first_exons, ignore_strand=True)
print(peaks_with_first_exons)
```

### 4.3 Resizing and Shifting Peaks

```{python}
narrow_peaks = peaks_chr22.narrow(start=10, width=100)
shifted_peaks = narrow_peaks.shift(10)

print("Narrowed and Shifted Peaks:")
print(shifted_peaks)
```

Resizing and shifting genomic ranges can be useful in various contexts. For example:
- Narrowing peaks might help focus on the center of ChIP-seq binding sites.
- Shifting ranges can be used to look at regions adjacent to your features of interest.

These operations demonstrate the flexibility of genomic range manipulations, which can be useful for fine-tuning analyses or testing hypotheses about the spatial relationships between genomic features.

## 5. Exercises

1. Calculate the average width of the ChIP-seq peaks on chromosome 22.
2. Determine how many peaks overlap with CpG islands.
3. Compute the percentage of promoter regions that have at least one overlapping ChIP-seq peak.

## Conclusion

In this tutorial, we've explored how to use BiocPy's genomic ranges functionality to perform various genomic analyses. These tools and techniques provide a powerful way to work with genomic interval data in Python, mirroring the capabilities from Bioconductor. They form the foundation for many more complex genomic analyses and can be applied to a wide range of biological questions.

:::{.callout-note}
Refer to the [BiocPy documentation](https://biocpy.github.io/) for more detailed information on these packages and their functionalities.
:::