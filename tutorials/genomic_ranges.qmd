# Tutorial 1: `GenomicRanges` and range-based analyses

Genomic range operations are fundamental to many bioinformatics analyses. They allow us to work with intervals of genomic coordinates, which is crucial for understanding the relationships between different genomic features such as genes, regulatory elements, and experimental data like ChIP-seq peaks. In this tutorial, we'll explore how to work with genomic interval data using BiocPy's [GenomicRanges](https://github.com/BiocPy/GenomicRanges/) package, which provides Python implementations similar to the R/Bioconductor [GenomicRanges package](https://github.com/Bioconductor/GenomicRanges).

## Outline

In this workshop, we'll walk through several key aspects of working with genomic ranges in Python:

1. Reading Genomic Data: We'll start by reading in genomic data from RDS files, including exon positions grouped by transcripts.
2. Basic Genomic Operations: We'll cover fundamental operations like finding transcription start sites (TSS) and promoter regions.
3. Overlap Analysis: We'll learn how to find overlaps between different genomic features, a common task in many analyses.
4. Advanced Operations: We'll explore more complex operations like finding peaks within specific regions and resizing genomic intervals.

## Prerequisites

Before we begin, please ensure that you have the following packages installed:

### Installation

Let's start by installing the required packages for R and Python.

::: {.panel-tabset}

## Python (shell)

You can install the Python packages using pip:

```sh
pip install -U biocutils genomicranges rds2py numpy pandas geniml
```

## R

```r
BiocManager::install(c("AnnotationHub"), 
     repos='http://cran.us.r-project.org')
```

:::

## 1. Save Annotations as RDS

Let's download the human reference genome and save the exon positions grouped by transcripts. For the purpose of the tutorial, we'll limit the exons to chromosome 22.

::: {.panel-tabset}

## R

```r
suppressMessages(library(AnnotationHub))

ah <- AnnotationHub()
ensdb <- query(ah, "Ensembl 112 EnsDb for Homo sapiens")[[1]]
exons_by_tx <- exonsBy(ensdb, 
    by = "tx", filter = SeqNameFilter(c("22")), 
    columns= c("exon_id", "tx_name", "tx_id", "gene_name", "gene_id"))
saveRDS(exons_by_tx, "hg38_exons_by_tx.rds")
```

:::

## 2. Reading RDS files in Python

The [rds2py](https://github.com/biocpy/rds2py) Python package allows us to read RDS files and create equivalent Python representations of R objects. Key features include:

- Parsing common R objects into Python equivalents (e.g., matrices to NumPy arrays, data frames to Pandas DataFrames).
- Ability to read S4 classes, enabling direct parsing of Bioconductor data types from R to Python.

Reading an RDS file with rds2py involves two steps:

1. Parse the RDS file into a Python dictionary containing data, its attributes, and associated metadata.
2. Convert this dictionary into a suitable Python object using specific parser functions.

This process allows a seamless transition between R and Python for bioinformatics analyses.

::: {.panel-tabset}

## Python
```{python}
from rds2py import read_rds
hg38_robject = read_rds("./hg38_exons_by_tx.rds")

from rds2py.granges import as_granges_list
by_tx = as_granges_list(hg38_robject)

print("Exons by transcript:")
print(by_tx)
```

:::

## 2. Basic Genomic Operations

Now, let's perform some basic operations like finding Transcription Start Sites (TSS) and promoter regions. These operations are fundamental in genomic analysis as they help us identify key regulatory regions of the genome.

### 2.1 Create a `GenomicRangesList` by gene

To identify TSS or define promoter regions, let's first reprocess the input to create a `GenomicRangesList` by gene symbols.

::: {.panel-tabset}

## Python

To achieve this, we unlist the `GenomicRangesList` object. This is accomplished in Python using the `as_genomic_ranges()` method. 

```{python}
all_ranges = by_tx.as_genomic_ranges()
```

Then we split the object using the `gene_name` metadata column in `mcols()`. 

:::{.callout-important}
We provide accessors to get or set attributes of the class. Most folks in Python may be familiar with direct access to class members (via properties or @property), but this should generally be avoided, as it is too easy to perform modifications via one-liners with the class.property on the left-hand side of an assignment.

For more information, please refer to our [developer guide](https://github.com/BiocPy/developer_guide).
:::

:::{.callout-note}
While gene IDs are unique, gene symbols are not. In addition, this list has genes with no symbols.
:::

```{python}
by_gene = all_ranges.split(
    groups=all_ranges.get_mcols().get_column("gene_name")
)

print("Exons by gene:")
print(by_gene)
```
:::

### 2.2 Finding Transcription Start Sites (TSS)

Transcription Start Sites (TSS) are the locations where transcription of a gene begins. Identifying TSS is crucial for understanding gene regulation, as many regulatory elements are located near the TSS. 

::: {.panel-tabset}

Let's use the `range()` method to get the full extent of each gene.

## Python

```{python}
ranges_by_gene = by_gene.range()

print("Gene ranges:")
print(ranges_by_gene)
```

We convert the list to a `GenomicRanges` object.

```{python}
gr_by_gene = ranges_by_gene.as_genomic_ranges()

print("as GenomicRanges:")
print(gr_by_gene)
```

Then we resize to a width of 1 base pair at the start of each range to pinpoint the TSS.

```{python}
tss = gr_by_gene.resize(width=1, fix="start")

print("Transcript Start Sites:")
print(gr_by_gene)
```
:::

### 2.3 Defining Promoter Regions

Here, we're defining promoters as the region 2000 base pairs upstream to 200 base pairs downstream of each TSS. This definition can vary depending on the specific analysis, but this range often captures important regulatory elements.

::: {.panel-tabset}

## Python
```{python}
promoters = tss.promoters(upstream=2000, downstream=200)

print("Promoter Regions:")
print(promoters)
```

:::{.callout-note}
Please be aware that because gene symbols may not be unique, this `GenomicRanges` object might contain duplicates. You might want to resolve duplicate symbols by making the symbols unique. We will leave this as an exercise for the reader.
:::

:::

## 3. Overlap Analysis

A common task in genomic analysis is finding overlaps between different genomic features. This helps us understand the relationships between various elements in the genome and can provide insights into gene regulation and function.

### 3.1 Reading ChIP-seq Peaks

ChIP-seq (Chromatin Immunoprecipitation followed by sequencing) is a method used to identify binding sites of DNA-associated proteins. The peaks represent regions where a protein of interest is likely bound to the DNA. We're focusing on chromosome 22 for this example to keep the dataset manageable.

For the purpose of this tutorial, let's download a bed file containing peaks from a ChIP-seq experiment on "Human B cells" to identify "EZH2" binding sites (from ENCODE) and cataloged in [bedbase.org](https://bedbase.org/bed/be4054acf6e3feeb4dc490e6430e358e).

::: {.panel-tabset}

## Python
```{python}
from geniml.bbclient import BBClient

bbclient = BBClient(cache_folder="cache", bedbase_api="https://api.bedbase.org")
bedfile_id = "be4054acf6e3feeb4dc490e6430e358e" 
bedfile = bbclient.load_bed(bedfile_id)
peaks = bedfile.to_granges()

filter_chr22 = [x == "chr22" for x in peaks.get_seqnames()]
peaks_chr22 = peaks[filter_chr22]

print(peaks_chr22)
```

:::

### 3.2 Finding Overlaps with TSS

Here, we're identifying ChIP-seq peaks that overlap with TSS. This analysis can help us understand if the protein of interest tends to bind near the start of genes, which could suggest a role in transcription initiation.

::: {.panel-tabset}

## Python

```{python}
overlaps = peaks_chr22.find_overlaps(tss)

print("Peak indices that overlap with first 10 TSS:")
print(overlaps[:10])
```

:::{.callout-note}
`find_overlaps` returns a `list` with the same length as TSS, indicating which indices from peaks overlap with each of the TSS. Ideally, we would want to return a `Hits` object similar to the Bioconductor implementation.

**TODO: Future plans to convert this into a `Hits` object.**
:::

Let's identify the peaks that overlap with TSS.

```{python}
import itertools

all_indices = list(set(itertools.chain.from_iterable(overlaps)))
peaks_by_tss = peaks_chr22[all_indices]
print(peaks_by_tss)
```

Instead, one can subset peaks that overlap with TSS using the `subset_by_overlaps` method:

```{python}
peaks_by_tss2 = peaks_chr22.subset_by_overlaps(tss)
print(peaks_by_tss2)
```

Additionally, in some cases, we may want to ignore strand information (`ignore_strand=True`) when finding overlaps.

```{python}
peaks_by_tss_ignoring_strand = peaks_chr22.subset_by_overlaps(tss, ignore_strand=True)
print(peaks_by_tss_ignoring_strand)
```

:::{.callout-note}
This yields the same results for this particular scenario, but may not if the 'peaks' contain strand information.
:::

:::

### 3.3 Finding Overlaps with Promoters

This operation finds ChIP-seq peaks that overlap with our defined promoter regions. If a significant number of peaks fall within promoters, it might suggest that the protein plays a role in gene regulation through promoter binding. This kind of analysis is often used to characterize the binding patterns of transcription factors or other regulatory proteins.

::: {.panel-tabset}

## Python

```{python}
peaks_by_promoters = peaks_chr22.subset_by_overlaps(promoters)

print("Peaks Overlapping with Promoters:")
print(peaks_by_promoters)
```

:::

### 3.4 Finding Overlaps with Exons

Another analysis is to look at overlaps with all exons. This can help identify potential roles of the ChIP-seq peaks in splicing. Let's modify our analysis to look at all exons:

::: {.panel-tabset}

## Python

```{python}
# Combine all exons into a single GenomicRanges object
all_exons = by_gene.as_granges()

# Find peaks overlapping with any exon
peaks_by_exons = peaks_chr22.subset_by_overlaps(all_exons)

print("Peaks overlapping with exons:")
print(peaks_by_exons)

# Calculate the percentage of peaks that overlap with exons
percent_overlapping = (len(peaks_by_exons) / len(peaks_chr22)) * 100

print(f"Percentage of peaks overlapping with exons: {percent_overlapping:.2f}%")
```

:::

This analysis can provide insights into whether the protein of interest (captured by the ChIP-seq: "EZH2") tends to bind within gene bodies, potentially influencing gene expression, splicing, or other co-transcriptional processes.

## 4. Advanced Operations

Let's explore some more complex operations that are often used in genomic analyses.

### 4.1 Comparing Exonic vs. Intronic Binding

Let's first identify intron regions. We will use the `by_gene` object we created that contains a `GenomicRangesList` split by gene.

::: {.panel-tabset}

## Python

```{python}
# Create intronic regions (regions within genes but not in exons)
gene_ranges = by_gene.range().as_genomic_ranges()  # Get the full extent of each gene
introns = gene_ranges.subtract(all_exons).as_granges()

print("Intron regions:")
print(introns)
```

To gain further insight, we can compare the proportion of peaks overlapping with exons to those overlapping with introns:

```{python}
# Find peaks overlapping with introns
peaks_by_introns = peaks_chr22.subset_by_overlaps(introns)

print("Peaks overlapping with introns:")
print(peaks_by_introns)

# Calculate percentages
percent_exonic = (len(peaks_by_exons) / len(peaks_chr22)) * 100
percent_intronic = (len(peaks_by_introns) / len(peaks_chr22)) * 100

print(f"Percentage of peaks overlapping with exons: {percent_exonic:.2f}%")
print(f"Percentage of peaks overlapping with introns: {percent_intronic:.2f}%")
```

:::

:::{.callout-note}
These percentages add up to over 100% because some peaks overlap both introns and exons, depending on how wide the peaks are. Ideally, you may want to filter the peaks based on preference as you annotate them with TSS, promoters, etc.
:::

This comparison can help determine if the protein of interest shows a preference for binding in exonic or intronic regions, which could suggest different functional roles (e.g., splicing regulation for exonic binding vs. potential enhancer activity for intronic binding).

### 4.2 Finding Overlaps with the first exon

:::{.callout-note}
- This analysis is performed by transcript.
- The rationale for this analysis may vary, but we are mostly showcasing complex genomic operations that are possible with the package.
:::

Let's first put together a `GenomicRanges` object containing the first exon for each transcript.

```{python}
all_first = []
for txid, grl in by_tx:
    strand = grl.get_strand(as_type = "list")[0]
    if strand == "-":
        all_first.append(grl.sort()[-1])
    else:
        all_first.append(grl.sort()[0])
```

Then we combine all the individual genomic elements. The [biocutils](https://github.com/BiocPy/BiocUtils) package provides utilities for convenient aspects of R that aren't provided by base Python and generics. One of these generics is the `'combine'` operation that merges or concatenates various Bioconductor classes.

```{python}
from biocutils import combine_sequences
first_exons = combine_sequences(*all_first)
```

We can now subset peaks that overlap with the first exon

```{python}
peaks_with_first_exons = peaks_chr22.subset_by_overlaps(first_exons)
print(peaks_with_first_exons)
```

### 4.3 Resizing and Shifting Peaks

```{python}
narrow_peaks = peaks_chr22.narrow(start=10, width=100)
shifted_peaks = narrow_peaks.shift(10)

print("Narrowed and Shifted Peaks:")
print(shifted_peaks)
```

Resizing and shifting genomic ranges can be useful in various contexts. For example:

- Narrowing peaks might help focus on the center of ChIP-seq binding sites.
- Shifting ranges can be used to look at regions adjacent to your features of interest. e.g. defining the predicted CRISPR cleavage site based on the position of the CRISPR gRNA sequence.

These operations demonstrate the flexibility of genomic range manipulations, which can be useful for fine-tuning analyses or testing hypotheses about the spatial relationships between genomic features.

## 5. Exercises

1. Calculate the average width of the ChIP-seq peaks on chromosome 22.
2. Determine how many peaks overlap with CpG islands.
3. Compute the percentage of promoter regions that have at least one overlapping ChIP-seq peak.

## Conclusion

In this tutorial, we've explored how to use BiocPy's genomic ranges functionality to perform various genomic analyses. These tools and techniques provide a powerful way to work with genomic interval data in Python, mirroring the capabilities from Bioconductor. They form the foundation for many more complex genomic analyses and can be applied to a wide range of biological questions.

:::{.callout-note}
Refer to the [BiocPy documentation](https://biocpy.github.io/) for more detailed information on these packages and their functionalities.
:::