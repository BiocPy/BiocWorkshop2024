# Tutorial 1: `GenomicRanges` and range-based analyses

Welcome to this tutorial on reading RDS files containing Bioconductor data objects in Python. The **rds2py** [Python](https://github.com/BiocPy/rds2py) allows us to parse, extract and create equivalent representations in Python for objects stored in these files. This eliminates the need for additional data conversion tools or intermediate formats, streamlining the transition between Python and R for seamless analysis.

What sets `rds2py` apart from other similar tools is its capability to read **S4** classes. This unique feature allows the parsing of Bioconductor data types directly from R into Python. The package implements bindings to Aaron's [rds2cpp library](https://github.com/LTLA/rds2cpp), that does most of the heavy lifting.

:::{.callout-tip}
This tutorial is inspired by 

- GRanges section from [Computational Genomics in R](https://compgenomr.github.io/book/operations-on-genomic-intervals-with-genomicranges-package.html#how-to-create-and-manipulate-a-granges-object) book.
:::

## Outline

In this tutorial, you will learn how to:

- Install and set up relevant BiocPy packages in your Python environment.
- Reading an RDS object contaning a `GenomicRanges` object.
- Exploring methods available in `GenomicRanges` in Python.

Let's dive into the process!

## Prerequisites

Before we begin, please ensure that you have the following prerequisites installed:

- Python 3.8 or later with dependencies listed [here]([../requirements.txt](https://github.com/BiocPy/BiocWorkshop2024/blob/master/requirements.txt)).
- R 4.4.0 and Bioconductor packages listed [here]([../rpackages.R](https://github.com/BiocPy/BiocWorkshop2024/blob/master/rpackages.R)).

## Installation

Let's start by installing the required packages.

## Save objects from AnnotationHub
```r
BiocManager::install(c("AnnotationHub", "TxDb.Hsapiens.UCSC.hg38.refGene"), 
     repos='http://cran.us.r-project.org')
```

For the purpose of the workshop, weâ€™ll use `AnnotationHub` to get the full set of CpG islands from UCSC in a `GRanges` object. 

```r
suppressMessages(library(AnnotationHub))
ahub <- AnnotationHub()
cpgs <- ahub[["AH5086"]]
```

We will then save this object as RDS file, for the purpose of the tutorial, lets limit the ranges to keep only "chr22":

```r
# cpg_path <- tempfile("cpgislands", fileext = ".rds")
keep.seqlevels <- c("chr22")
filtered <- subset(cpgs, seqnames(cpgs) %in% keep.seqlevels)
saveRDS(filtered, "./cpgislands.rds")
```

While we are still in the R session, lets download the human reference genome and extracting transcription start sites.
We need do a bit of pre-processing to get this information.

```r
suppressMessages(library(TxDb.Hsapiens.UCSC.hg38.refGene))
genome <- TxDb.Hsapiens.UCSC.hg38.refGene
seqlevels(genome) <- "chr22"
exons_hg38 <- exonsBy(genome, by = "tx")

saveRDS(exons_hg38, "./hg38_exons_by_tx.rds")
```

Now that we have these objects saved as RDS files, we'll switch to Python for the rest of this tutorial.

## Reading RDS files in Python

Reading an RDS file in Python is a two-step process. First, we parse the serialized RDS into a readable Python object, typically a dictionary. This object contains both the data and relevant metadata about the structure and internal representation of the R object. Subsequently, we use one of the parser functions to convert this object into a Python representation.


```{python}
from rds2py import read_rds

hg38_robject = read_rds("./hg38_exons_by_tx.rds")

from rds2py.granges import as_granges_list

hg38_grl = as_granges_list(hg38_robject)

print("\nhg38 genome exons by transcript \n")
print(hg38_grl)
```

### Usecase: Annotating peaks from a ChIP-seq experiment

A common task I've seen folks perform is finding overlapping regions. e.g. to annotate binding sites with genomic annotations such as promoter, exon, intron and/or CpG islands, which are important for gene regulation.

For the purpose of this tutorial, lets download a bed file containing peaks from a ChIP-seq experiments on human B cells run by ENCODE and catalogued in [bedbase.org](https://bedbase.org/bed/be4054acf6e3feeb4dc490e6430e358e).

```{python}
from geniml.bbclient import BBClient

bbclient = BBClient(cache_folder="cache", bedbase_api="https://api.bedbase.org")
bedfile_id = "be4054acf6e3feeb4dc490e6430e358e" 
bedfile = bbclient.load_bed(bedfile_id)
peaks = bedfile.to_granges()

filter_chr22 = [x == "chr22" for x in peaks.get_seqnames()]
peaks_chr22 = peaks[filter_chr22]

print(peaks_chr22)
```

### Overlaps with Transcription Start Sites (TSS)

Lets access the Transcription Start Sites (TSS) from the reference genome. This can be accomplished by computing the ranges of each genomic element (in our case the GenomicRangesList is split by transcripts already) and resizing the object to one base:

::: {.panel-tabset}

## Python
```{python}
tss = hg38_grl \
     .range() \
     .as_genomic_ranges() \
     .resize(width=1, fix="start")

print(tss)
```

## R

```r
# R script to perform the same operation
```

:::

Now, lets find peaks that overlap with TSS. This is accomplished by the `find_overlaps` method.

::: {.panel-tabset}

## Python

```{python}
overlaps = peaks_chr22.find_overlaps(tss)
print(len(overlaps))
```

:::{.callout-note}
Find overlaps returns a `list` with the same length as TSS, indicating which indices from peaks overlap with each of the TSS. Ideally, we would want to return a `Hits` object similar to Bioconductor implementation.
:::

we can iterate the indices from the object and filter the peaks that overlap with TSS

```{python}
import itertools

all_indices = list(set(itertools.chain.from_iterable(overlaps)))
peaks_with_tss = peaks_chr22[all_indices]
print(peaks_with_tss)
```

## R

```r
# R script to perform the same operation
```

:::

Alternatively, one can subset peaks that overlap with TSS using the `subset_by_overlaps` method:

::: {.panel-tabset}

## Python

```{python}
peaks_with_tss2 = peaks_chr22.subset_by_overlaps(tss)
print(peaks_with_tss2)
```

## R

```r
# R script to perform the same operation
```

:::

## Overlap with promoter regions

To identify peaks that overlap with promoter regions, lets first compute promoter regions.

The first step in this process is to extract the first exon from the genomic ranges list.

::: {.panel-tabset}

## Python (shell)

```{python}
all_first = []
for txid, grl in hg38_grl:
    strand = grl.get_strand(as_type = "list")[0]
    if strand == "-":
        all_first.append(grl.sort()[-1])
    else:
        all_first.append(grl.sort()[0])
```

Then we combine all the individual genomic elements. The `biocutils` package provides various generics that provide bioconductor-like functionality. 

```{python}
from biocutils import combine_sequences
grs = combine_sequences(*all_first)
```

Now we can use the `promoters()` method to compute the promoter regions for each transcript

```{python}
promoters = grs.promoters()
print(promoters)
```

We can then finally subset peaks that overlap with promoter regions

```{python}
peaks_with_promoters = peaks_chr22.subset_by_overlaps(promoters)
print(peaks_with_promoters)
```

## R

```r
# R script to perform the same operation
```

:::

### non-gene/transcipt regions 

In this example, lets compute non-gene regions and find peaks that overlap outside of genes

::: {.panel-tabset}

## Python (shell)

```{python}
all_gr = hg38_grl.as_granges()
non_gene_gr = all_gr.reduce().gaps()
print(non_gene_gr)
```

We can then identify peaks that overlap with these regions

```{python}
peaks_with_promoters = peaks_chr22.subset_by_overlaps(non_gene_gr)
print(peaks_with_promoters)
```

## R

```r
# R script to perform the same operation
```

:::

:::{.callout-note}

I wanted to show an example with finding overlaps with integenic regions, but the original object I used did not contain gene information. But this demonstrates some of the complex range based operations.
:::

### Peaks contained within regions

```{python}
peaks_with_promoters = peaks_chr22.subset_by_overlaps(non_gene_gr, query_type="within")
print(peaks_with_promoters)
```

### are you peaks too wide?

```{python}
narrow_peaks = peaks_chr22.narrow(start=10, width = 100)
print(narrow_peaks)
```

#### resize and shift

```{python}
resized = peaks_chr22.resize(100).shift(10)
print(resized)
```